// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace Client.Generated.Models
{
    /// <summary>
    /// MAY contain additional properties other than the required property `datetime`, e.g. custom properties or properties from the STAC specification or STAC extensions.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class Batch_job_result_properties : IAdditionalDataHolder, IParsable
    {
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>Date and time of creation, formatted as a [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339.html) date-time.</summary>
        public DateTimeOffset? Created { get; set; }
        /// <summary>The searchable date/time of the data, in UTC. Formatted as a [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339.html) date-time.If this field is set to `null` (usually for larger time ranges), it is STRONGLY RECOMMENDED to specify both `start_datetime` and `end_datetime` for STAC compliance.</summary>
        public DateTimeOffset? Datetime { get; set; }
        /// <summary>Detailed multi-line description to explain the entity.[CommonMark 0.29](http://commonmark.org/) syntax MAY be used for rich text representation.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Description { get; set; }
#nullable restore
#else
        public string Description { get; set; }
#endif
        /// <summary>For time series: The last or end date and time for the data, in UTC. Formatted as a [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339.html) date-time.</summary>
        public DateTimeOffset? EndDatetime { get; set; }
        /// <summary>Time until which the assets are accessible, in UTC. Formatted as a [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339.html) date-time.</summary>
        public DateTimeOffset? Expires { get; set; }
        /// <summary>License(s) of the data as a SPDX [License identifier](https://spdx.org/licenses/).Alternatively, use `proprietary` if the license is not on the SPDXlicense list or `various` if multiple licenses apply. In these two caseslinks to the license texts SHOULD be added, see the `license` linkrelation type.Non-SPDX licenses SHOULD add a link to the license text with the`license` relation in the links section. The license text MUST NOT beprovided as a value of this field. If there is no public license URLavailable, it is RECOMMENDED to host the license text and link to it.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? License { get; set; }
#nullable restore
#else
        public string License { get; set; }
#endif
        /// <summary>The status of a batch job.This field is REQUIRED if the `partial` parameter is given.This field is strongly RECOMMENDED if the job has stopped due to an error.</summary>
        public global::Client.Generated.Models.Result_status? OpeneoStatus { get; set; }
        /// <summary>A list of providers, which MAY include all organizations capturing or processing the data or the hosting provider. Providers SHOULD be listed in chronological order with the most recent provider being the last element of the list.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::Client.Generated.Models.Results>? Providers { get; set; }
#nullable restore
#else
        public List<global::Client.Generated.Models.Results> Providers { get; set; }
#endif
        /// <summary>For time series: The first or start date and time for the data, in UTC. Formatted as a [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339.html) date-time.</summary>
        public DateTimeOffset? StartDatetime { get; set; }
        /// <summary>A short description to easily distinguish entities.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Title { get; set; }
#nullable restore
#else
        public string Title { get; set; }
#endif
        /// <summary>Date and time of the last status change, formatted as a [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339.html) date-time.</summary>
        public DateTimeOffset? Updated { get; set; }
        /// <summary>
        /// Instantiates a new <see cref="global::Client.Generated.Models.Batch_job_result_properties"/> and sets the default values.
        /// </summary>
        public Batch_job_result_properties()
        {
            AdditionalData = new Dictionary<string, object>();
            OpeneoStatus = global::Client.Generated.Models.Result_status.Finished;
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::Client.Generated.Models.Batch_job_result_properties"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::Client.Generated.Models.Batch_job_result_properties CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            if(ReferenceEquals(parseNode, null)) throw new ArgumentNullException(nameof(parseNode));
            return new global::Client.Generated.Models.Batch_job_result_properties();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "created", n => { Created = n.GetDateTimeOffsetValue(); } },
                { "datetime", n => { Datetime = n.GetDateTimeOffsetValue(); } },
                { "description", n => { Description = n.GetStringValue(); } },
                { "end_datetime", n => { EndDatetime = n.GetDateTimeOffsetValue(); } },
                { "expires", n => { Expires = n.GetDateTimeOffsetValue(); } },
                { "license", n => { License = n.GetStringValue(); } },
                { "openeo:status", n => { OpeneoStatus = n.GetEnumValue<global::Client.Generated.Models.Result_status>(); } },
                { "providers", n => { Providers = n.GetCollectionOfObjectValues<global::Client.Generated.Models.Results>(global::Client.Generated.Models.Results.CreateFromDiscriminatorValue)?.AsList(); } },
                { "start_datetime", n => { StartDatetime = n.GetDateTimeOffsetValue(); } },
                { "title", n => { Title = n.GetStringValue(); } },
                { "updated", n => { Updated = n.GetDateTimeOffsetValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            if(ReferenceEquals(writer, null)) throw new ArgumentNullException(nameof(writer));
            writer.WriteDateTimeOffsetValue("created", Created);
            writer.WriteDateTimeOffsetValue("datetime", Datetime);
            writer.WriteStringValue("description", Description);
            writer.WriteDateTimeOffsetValue("end_datetime", EndDatetime);
            writer.WriteDateTimeOffsetValue("expires", Expires);
            writer.WriteStringValue("license", License);
            writer.WriteEnumValue<global::Client.Generated.Models.Result_status>("openeo:status", OpeneoStatus);
            writer.WriteCollectionOfObjectValues<global::Client.Generated.Models.Results>("providers", Providers);
            writer.WriteDateTimeOffsetValue("start_datetime", StartDatetime);
            writer.WriteStringValue("title", Title);
            writer.WriteDateTimeOffsetValue("updated", Updated);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
#pragma warning restore CS0618
