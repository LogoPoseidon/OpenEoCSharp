// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace Client.Generated.Models
{
    /// <summary>
    /// A JSON Schema compliant to [JSON Schema draft-07](https://json-schema.org/draft-07/json-schema-validation.html) or later.JSON Schemas SHOULD always be dereferenced (i.e. all `$refs` should be resolved).This allows clients to consume the schemas much better.Clients are not expected to support dereferencing `$refs`.Note: The specified schema in the OpenAPI document is only a common subset of JSON Schema.Additional keywords from the JSON Schema specification MAY be used.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class Json_schema : IAdditionalDataHolder, IParsable
    {
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>An exclusive list of allowed values.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public UntypedNode? Enum { get; set; }
#nullable restore
#else
        public UntypedNode Enum { get; set; }
#endif
        /// <summary>ID of your JSON Schema.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Id { get; set; }
#nullable restore
#else
        public string Id { get; set; }
#endif
        /// <summary>Specifies schemas for the items in an array.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Client.Generated.Models.Json_schema.Json_schema_items? Items { get; set; }
#nullable restore
#else
        public global::Client.Generated.Models.Json_schema.Json_schema_items Items { get; set; }
#endif
        /// <summary>The maximum value (inclusive) allowed for a numerical value.</summary>
        public double? Maximum { get; set; }
        /// <summary>The maximum number of items required in an array.</summary>
        public double? MaxItems { get; set; }
        /// <summary>The minimum value (inclusive) allowed for a numerical value.</summary>
        public double? Minimum { get; set; }
        /// <summary>The minimum number of items required in an array.</summary>
        public double? MinItems { get; set; }
        /// <summary>The regular expression a string value must match against.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Pattern { get; set; }
#nullable restore
#else
        public string Pattern { get; set; }
#endif
        /// <summary>The JSON Schema version. If not given in the context of openEO,defaults to `draft-07`.You may need to add the default value for `$schema` property explicitly to the JSON Schemaobject before passing it to a JSON Schema validator.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Schema { get; set; }
#nullable restore
#else
        public string Schema { get; set; }
#endif
        /// <summary>The allowed basic data type(s) for a value.If this property is not present, all data types are allowed.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Client.Generated.Models.Json_schema.Json_schema_type? Type { get; set; }
#nullable restore
#else
        public global::Client.Generated.Models.Json_schema.Json_schema_type Type { get; set; }
#endif
        /// <summary>
        /// Instantiates a new <see cref="global::Client.Generated.Models.Json_schema"/> and sets the default values.
        /// </summary>
        public Json_schema()
        {
            AdditionalData = new Dictionary<string, object>();
            Schema = "http://json-schema.org/draft-07/schema#";
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::Client.Generated.Models.Json_schema"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::Client.Generated.Models.Json_schema CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            if(ReferenceEquals(parseNode, null)) throw new ArgumentNullException(nameof(parseNode));
            return new global::Client.Generated.Models.Json_schema();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "enum", n => { Enum = n.GetObjectValue<UntypedNode>(UntypedNode.CreateFromDiscriminatorValue); } },
                { "$id", n => { Id = n.GetStringValue(); } },
                { "items", n => { Items = n.GetObjectValue<global::Client.Generated.Models.Json_schema.Json_schema_items>(global::Client.Generated.Models.Json_schema.Json_schema_items.CreateFromDiscriminatorValue); } },
                { "maxItems", n => { MaxItems = n.GetDoubleValue(); } },
                { "maximum", n => { Maximum = n.GetDoubleValue(); } },
                { "minItems", n => { MinItems = n.GetDoubleValue(); } },
                { "minimum", n => { Minimum = n.GetDoubleValue(); } },
                { "pattern", n => { Pattern = n.GetStringValue(); } },
                { "$schema", n => { Schema = n.GetStringValue(); } },
                { "type", n => { Type = n.GetObjectValue<global::Client.Generated.Models.Json_schema.Json_schema_type>(global::Client.Generated.Models.Json_schema.Json_schema_type.CreateFromDiscriminatorValue); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            if(ReferenceEquals(writer, null)) throw new ArgumentNullException(nameof(writer));
            writer.WriteObjectValue<UntypedNode>("enum", Enum);
            writer.WriteStringValue("$id", Id);
            writer.WriteObjectValue<global::Client.Generated.Models.Json_schema.Json_schema_items>("items", Items);
            writer.WriteDoubleValue("maximum", Maximum);
            writer.WriteDoubleValue("maxItems", MaxItems);
            writer.WriteDoubleValue("minimum", Minimum);
            writer.WriteDoubleValue("minItems", MinItems);
            writer.WriteStringValue("pattern", Pattern);
            writer.WriteStringValue("$schema", Schema);
            writer.WriteObjectValue<global::Client.Generated.Models.Json_schema.Json_schema_type>("type", Type);
            writer.WriteAdditionalData(AdditionalData);
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Client.Generated.Models.Json_schema"/>, List&lt;global::Client.Generated.Models.Json_schema&gt;
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class Json_schema_items : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type List&lt;global::Client.Generated.Models.Json_schema&gt;</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public List<global::Client.Generated.Models.Json_schema>? JsonSchema { get; set; }
#nullable restore
#else
            public List<global::Client.Generated.Models.Json_schema> JsonSchema { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="global::Client.Generated.Models.Json_schema"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Client.Generated.Models.Json_schema? JsonSchemaItemsJsonSchema { get; set; }
#nullable restore
#else
            public global::Client.Generated.Models.Json_schema JsonSchemaItemsJsonSchema { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Client.Generated.Models.Json_schema.Json_schema_items"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Client.Generated.Models.Json_schema.Json_schema_items CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                if(ReferenceEquals(parseNode, null)) throw new ArgumentNullException(nameof(parseNode));
                var result = new global::Client.Generated.Models.Json_schema.Json_schema_items();
                if(parseNode.GetCollectionOfObjectValues<global::Client.Generated.Models.Json_schema>(global::Client.Generated.Models.Json_schema.CreateFromDiscriminatorValue)?.AsList() is List<global::Client.Generated.Models.Json_schema> jsonSchemaValue)
                {
                    result.JsonSchema = jsonSchemaValue;
                }
                else {
                    result.JsonSchemaItemsJsonSchema = new global::Client.Generated.Models.Json_schema();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(JsonSchemaItemsJsonSchema != null)
                {
                    return ParseNodeHelper.MergeDeserializersForIntersectionWrapper(JsonSchemaItemsJsonSchema);
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                if(ReferenceEquals(writer, null)) throw new ArgumentNullException(nameof(writer));
                if(JsonSchema != null)
                {
                    writer.WriteCollectionOfObjectValues<global::Client.Generated.Models.Json_schema>(null, JsonSchema);
                }
                else {
                    writer.WriteObjectValue<global::Client.Generated.Models.Json_schema>(null, JsonSchemaItemsJsonSchema);
                }
            }
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Client.Generated.Models.Json_schema_type"/>, List&lt;global::Client.Generated.Models.Json_schema_type&gt;
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class Json_schema_type : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type List&lt;global::Client.Generated.Models.Json_schema_type&gt;</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public List<global::Client.Generated.Models.Json_schema_type?>? JsonSchemaType { get; set; }
#nullable restore
#else
            public List<global::Client.Generated.Models.Json_schema_type?> JsonSchemaType { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="global::Client.Generated.Models.Json_schema_type"/></summary>
            public global::Client.Generated.Models.Json_schema_type? JsonSchemaTypeJsonSchemaType { get; set; }
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Client.Generated.Models.Json_schema.Json_schema_type"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Client.Generated.Models.Json_schema.Json_schema_type CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                if(ReferenceEquals(parseNode, null)) throw new ArgumentNullException(nameof(parseNode));
                var mappingValue = parseNode.GetChildNode("")?.GetStringValue();
                var result = new global::Client.Generated.Models.Json_schema.Json_schema_type();
                if(parseNode.GetEnumValue<global::Client.Generated.Models.Json_schema_type>() is global::Client.Generated.Models.Json_schema_type jsonSchemaTypeJsonSchemaTypeValue)
                {
                    result.JsonSchemaTypeJsonSchemaType = jsonSchemaTypeJsonSchemaTypeValue;
                }
                else if(parseNode.GetCollectionOfEnumValues<global::Client.Generated.Models.Json_schema_type>()?.AsList() is List<global::Client.Generated.Models.Json_schema_type?> jsonSchemaTypeValue)
                {
                    result.JsonSchemaType = jsonSchemaTypeValue;
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                if(ReferenceEquals(writer, null)) throw new ArgumentNullException(nameof(writer));
                if(JsonSchemaTypeJsonSchemaType != null)
                {
                    writer.WriteEnumValue<global::Client.Generated.Models.Json_schema_type>(null, JsonSchemaTypeJsonSchemaType);
                }
                else if(JsonSchemaType != null)
                {
                    writer.WriteCollectionOfEnumValues<global::Client.Generated.Models.Json_schema_type>(null, JsonSchemaType);
                }
            }
        }
    }
}
#pragma warning restore CS0618
