// <auto-generated/>
#pragma warning disable CS0618
using Client.Generated.Models;
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using Microsoft.Kiota.Abstractions;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using System.Threading;
using System;
namespace Client.Generated.Validation
{
    /// <summary>
    /// Builds and executes requests for operations under \validation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class ValidationRequestBuilder : BaseRequestBuilder
    {
        /// <summary>
        /// Instantiates a new <see cref="global::Client.Generated.Validation.ValidationRequestBuilder"/> and sets the default values.
        /// </summary>
        /// <param name="pathParameters">Path parameters for the request</param>
        /// <param name="requestAdapter">The request adapter to use to execute the requests.</param>
        public ValidationRequestBuilder(Dictionary<string, object> pathParameters, IRequestAdapter requestAdapter) : base(requestAdapter, "{+baseurl}/validation", pathParameters)
        {
        }
        /// <summary>
        /// Instantiates a new <see cref="global::Client.Generated.Validation.ValidationRequestBuilder"/> and sets the default values.
        /// </summary>
        /// <param name="rawUrl">The raw URL to use for the request builder.</param>
        /// <param name="requestAdapter">The request adapter to use to execute the requests.</param>
        public ValidationRequestBuilder(string rawUrl, IRequestAdapter requestAdapter) : base(requestAdapter, "{+baseurl}/validation", rawUrl)
        {
        }
        /// <summary>
        /// Validates a user-defined process without executing it. A user-defined process isconsidered valid unless the `errors` array in the response contains atleast one error.Checks whether the process graph is schematically correct and theprocesses are supported by the back-end. It MUST also check thearguments against the schema, but checking whether the arguments areadequate in the context of data is OPTIONAL. For example, a non-existingband name may get rejected only by a few back-ends.The validation MUST NOT throw an error for unresolvable process parameters.Back-ends MUST validate the process graph. Validating the correspondingmetadata is OPTIONAL.Errors that usually occur during processing MAY NOT get reported, e.g.if a referenced file is accessible at the time of execution.Back-ends can either report all errors at once or stop the validationonce they found the first error. Please note that a validation always returns with HTTP status code 200.Error codes in the 4xx and 5xx ranges MUST be returned only when thegeneral validation request is invalid (e.g. server is busy or propertiesin the request body are missing), but never if an error was found duringvalidation of the user-defined process (e.g. an unsupported process).
        /// </summary>
        /// <returns>A <see cref="global::Client.Generated.Validation.ValidationPostResponse"/></returns>
        /// <param name="body">A process graph, optionally enriched with process metadata.</param>
        /// <param name="cancellationToken">Cancellation token to use when cancelling requests</param>
        /// <param name="requestConfiguration">Configuration for the request such as headers, query parameters, and middleware options.</param>
        /// <exception cref="global::Client.Generated.Models.Error">When receiving a 4XX or 5XX status code</exception>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public async Task<global::Client.Generated.Validation.ValidationPostResponse?> PostAsValidationPostResponseAsync(global::Client.Generated.Models.Process_graph_with_metadata body, Action<RequestConfiguration<DefaultQueryParameters>>? requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#nullable restore
#else
        public async Task<global::Client.Generated.Validation.ValidationPostResponse> PostAsValidationPostResponseAsync(global::Client.Generated.Models.Process_graph_with_metadata body, Action<RequestConfiguration<DefaultQueryParameters>> requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#endif
            if(ReferenceEquals(body, null)) throw new ArgumentNullException(nameof(body));
            var requestInfo = ToPostRequestInformation(body, requestConfiguration);
            var errorMapping = new Dictionary<string, ParsableFactory<IParsable>>
            {
                { "XXX", global::Client.Generated.Models.Error.CreateFromDiscriminatorValue },
            };
            return await RequestAdapter.SendAsync<global::Client.Generated.Validation.ValidationPostResponse>(requestInfo, global::Client.Generated.Validation.ValidationPostResponse.CreateFromDiscriminatorValue, errorMapping, cancellationToken).ConfigureAwait(false);
        }
        /// <summary>
        /// Validates a user-defined process without executing it. A user-defined process isconsidered valid unless the `errors` array in the response contains atleast one error.Checks whether the process graph is schematically correct and theprocesses are supported by the back-end. It MUST also check thearguments against the schema, but checking whether the arguments areadequate in the context of data is OPTIONAL. For example, a non-existingband name may get rejected only by a few back-ends.The validation MUST NOT throw an error for unresolvable process parameters.Back-ends MUST validate the process graph. Validating the correspondingmetadata is OPTIONAL.Errors that usually occur during processing MAY NOT get reported, e.g.if a referenced file is accessible at the time of execution.Back-ends can either report all errors at once or stop the validationonce they found the first error. Please note that a validation always returns with HTTP status code 200.Error codes in the 4xx and 5xx ranges MUST be returned only when thegeneral validation request is invalid (e.g. server is busy or propertiesin the request body are missing), but never if an error was found duringvalidation of the user-defined process (e.g. an unsupported process).
        /// </summary>
        /// <returns>A <see cref="global::Client.Generated.Validation.ValidationResponse"/></returns>
        /// <param name="body">A process graph, optionally enriched with process metadata.</param>
        /// <param name="cancellationToken">Cancellation token to use when cancelling requests</param>
        /// <param name="requestConfiguration">Configuration for the request such as headers, query parameters, and middleware options.</param>
        /// <exception cref="global::Client.Generated.Models.Error">When receiving a 4XX or 5XX status code</exception>
        [Obsolete("This method is obsolete. Use PostAsValidationPostResponseAsync instead.")]
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public async Task<global::Client.Generated.Validation.ValidationResponse?> PostAsync(global::Client.Generated.Models.Process_graph_with_metadata body, Action<RequestConfiguration<DefaultQueryParameters>>? requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#nullable restore
#else
        public async Task<global::Client.Generated.Validation.ValidationResponse> PostAsync(global::Client.Generated.Models.Process_graph_with_metadata body, Action<RequestConfiguration<DefaultQueryParameters>> requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#endif
            if(ReferenceEquals(body, null)) throw new ArgumentNullException(nameof(body));
            var requestInfo = ToPostRequestInformation(body, requestConfiguration);
            var errorMapping = new Dictionary<string, ParsableFactory<IParsable>>
            {
                { "XXX", global::Client.Generated.Models.Error.CreateFromDiscriminatorValue },
            };
            return await RequestAdapter.SendAsync<global::Client.Generated.Validation.ValidationResponse>(requestInfo, global::Client.Generated.Validation.ValidationResponse.CreateFromDiscriminatorValue, errorMapping, cancellationToken).ConfigureAwait(false);
        }
        /// <summary>
        /// Validates a user-defined process without executing it. A user-defined process isconsidered valid unless the `errors` array in the response contains atleast one error.Checks whether the process graph is schematically correct and theprocesses are supported by the back-end. It MUST also check thearguments against the schema, but checking whether the arguments areadequate in the context of data is OPTIONAL. For example, a non-existingband name may get rejected only by a few back-ends.The validation MUST NOT throw an error for unresolvable process parameters.Back-ends MUST validate the process graph. Validating the correspondingmetadata is OPTIONAL.Errors that usually occur during processing MAY NOT get reported, e.g.if a referenced file is accessible at the time of execution.Back-ends can either report all errors at once or stop the validationonce they found the first error. Please note that a validation always returns with HTTP status code 200.Error codes in the 4xx and 5xx ranges MUST be returned only when thegeneral validation request is invalid (e.g. server is busy or propertiesin the request body are missing), but never if an error was found duringvalidation of the user-defined process (e.g. an unsupported process).
        /// </summary>
        /// <returns>A <see cref="RequestInformation"/></returns>
        /// <param name="body">A process graph, optionally enriched with process metadata.</param>
        /// <param name="requestConfiguration">Configuration for the request such as headers, query parameters, and middleware options.</param>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public RequestInformation ToPostRequestInformation(global::Client.Generated.Models.Process_graph_with_metadata body, Action<RequestConfiguration<DefaultQueryParameters>>? requestConfiguration = default)
        {
#nullable restore
#else
        public RequestInformation ToPostRequestInformation(global::Client.Generated.Models.Process_graph_with_metadata body, Action<RequestConfiguration<DefaultQueryParameters>> requestConfiguration = default)
        {
#endif
            if(ReferenceEquals(body, null)) throw new ArgumentNullException(nameof(body));
            var requestInfo = new RequestInformation(Method.POST, UrlTemplate, PathParameters);
            requestInfo.Configure(requestConfiguration);
            requestInfo.Headers.TryAdd("Accept", "application/json");
            requestInfo.SetContentFromParsable(RequestAdapter, "application/json", body);
            return requestInfo;
        }
        /// <summary>
        /// Returns a request builder with the provided arbitrary URL. Using this method means any other path or query parameters are ignored.
        /// </summary>
        /// <returns>A <see cref="global::Client.Generated.Validation.ValidationRequestBuilder"/></returns>
        /// <param name="rawUrl">The raw URL to use for the request builder.</param>
        public global::Client.Generated.Validation.ValidationRequestBuilder WithUrl(string rawUrl)
        {
            return new global::Client.Generated.Validation.ValidationRequestBuilder(rawUrl, RequestAdapter);
        }
        /// <summary>
        /// Configuration for the request such as headers, query parameters, and middleware options.
        /// </summary>
        [Obsolete("This class is deprecated. Please use the generic RequestConfiguration class generated by the generator.")]
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class ValidationRequestBuilderPostRequestConfiguration : RequestConfiguration<DefaultQueryParameters>
        {
        }
    }
}
#pragma warning restore CS0618
