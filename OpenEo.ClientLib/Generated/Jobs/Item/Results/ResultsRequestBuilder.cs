// <auto-generated/>
#pragma warning disable CS0618
using Client.Generated.Models;
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using Microsoft.Kiota.Abstractions;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using System.Threading;
using System;
namespace Client.Generated.Jobs.Item.Results
{
    /// <summary>
    /// Builds and executes requests for operations under \jobs\{job_id}\results
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class ResultsRequestBuilder : BaseRequestBuilder
    {
        /// <summary>
        /// Instantiates a new <see cref="global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder"/> and sets the default values.
        /// </summary>
        /// <param name="pathParameters">Path parameters for the request</param>
        /// <param name="requestAdapter">The request adapter to use to execute the requests.</param>
        public ResultsRequestBuilder(Dictionary<string, object> pathParameters, IRequestAdapter requestAdapter) : base(requestAdapter, "{+baseurl}/jobs/{job_id}/results{?partial*}", pathParameters)
        {
        }
        /// <summary>
        /// Instantiates a new <see cref="global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder"/> and sets the default values.
        /// </summary>
        /// <param name="rawUrl">The raw URL to use for the request builder.</param>
        /// <param name="requestAdapter">The request adapter to use to execute the requests.</param>
        public ResultsRequestBuilder(string rawUrl, IRequestAdapter requestAdapter) : base(requestAdapter, "{+baseurl}/jobs/{job_id}/results{?partial*}", rawUrl)
        {
        }
        /// <summary>
        /// Cancels all related computations for this job at the back-end. It willstop generating additional costs for processing.A subset of processed results may be available for downloading dependingon the state of the job at the time it was canceled.Results MUST NOT be deleted until the job processing is started again orthe job is completely deleted through a request to`DELETE /jobs/{job_id}`.This endpoint only has an effect if the job status is `queued` or`running`.The job status is set to `canceled` if the status was `running`beforehand and partial or preliminary results are available to bedownloaded. Otherwise the status is set to `created`. 
        /// </summary>
        /// <param name="cancellationToken">Cancellation token to use when cancelling requests</param>
        /// <param name="requestConfiguration">Configuration for the request such as headers, query parameters, and middleware options.</param>
        /// <exception cref="global::Client.Generated.Models.Error">When receiving a 4XX or 5XX status code</exception>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public async Task DeleteAsync(Action<RequestConfiguration<DefaultQueryParameters>>? requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#nullable restore
#else
        public async Task DeleteAsync(Action<RequestConfiguration<DefaultQueryParameters>> requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#endif
            var requestInfo = ToDeleteRequestInformation(requestConfiguration);
            var errorMapping = new Dictionary<string, ParsableFactory<IParsable>>
            {
                { "XXX", global::Client.Generated.Models.Error.CreateFromDiscriminatorValue },
            };
            await RequestAdapter.SendNoContentAsync(requestInfo, errorMapping, cancellationToken).ConfigureAwait(false);
        }
        /// <summary>
        /// Lists signed URLs pointing to the processed files, usually after the batch jobhas finished. Back-ends may also point to intermediate results after thejob has stopped due to an error or if the `partial` parameter has been set.The response includes additional metadata. It is a valid[STAC Item](https://github.com/radiantearth/stac-spec/tree/v1.0.0/item-spec)(if it has spatial and temporal references included) or a valid[STAC Collection](https://github.com/radiantearth/stac-spec/tree/v1.0.0/collection-spec)(supported since openEO API version 1.1.0).The assets to download are in both cases available in the property `assets`and have the same structure. All additional metadata is not strictly requiredto download the files, but are helpful for users to understand the data.STAC Collections can either (1) add all assets as collection-level assets or(2) link to STAC Catalogs and STAC Items with signed URLs, which will provide a fullSTAC catalog structure a client has to go through. Option 2 is overall the better architectural choice and allows a fine-grained description of the processed data,but it is not compliant with previous versions of the openEO API.**To maintain backward compatibility, it is REQUIRED to still copyall assets in the STAC catalog structure into the collection-level assets.**This requirement is planned to be removed in openEO API version 2.0.0.A client can enforce that the server returns a GeoJSON through content negotiationwith the media type `application/geo+json`, but the results may not contain verymeaningful metadata aside from the assets.Clients are RECOMMENDED to store this response and all potential sub-catalogsand items with the assets so that the downloaded data is then a self-containedSTAC catalog user could publish easily with all the data and metadata.URL signing is a way to protect files from unauthorized access with akey in the URL instead of HTTP header based authorization. The URLsigning key is similar to a password and its inclusion in the URL allowsto download files using simple GET requests supported by a wide range ofprograms, e.g. web browsers or download managers. Back-ends areresponsible to generate the URL signing keys and to manage theirappropriate expiration. The back-end MAY indicate an expiration time bysetting the `expires` property in the reponse. Requesting this endpointSHOULD always return non-expired URLs. Signed URLs that were generatedfor a previous request and already expired SHOULD NOT be reused,but regenerated with new expiration time.Signed URLs that expired MAY return the openEO error `ResultLinkExpired`.It is **strongly recommended** to add a link with relation type `canonical`to the STAC Item or STAC Collection (see the `links` property for details).If processing has not finished yet and the `partial` parameter is not set to `true`requests to this endpoint MUST be rejected with openEO error `JobNotFinished`.
        /// </summary>
        /// <returns>A <see cref="global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsGetResponse"/></returns>
        /// <param name="cancellationToken">Cancellation token to use when cancelling requests</param>
        /// <param name="requestConfiguration">Configuration for the request such as headers, query parameters, and middleware options.</param>
        /// <exception cref="global::Client.Generated.Models.Log_entry">When receiving a 424 status code</exception>
        /// <exception cref="global::Client.Generated.Models.Error">When receiving a 4XX or 5XX status code</exception>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public async Task<global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsGetResponse?> GetAsResultsGetResponseAsync(Action<RequestConfiguration<global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsRequestBuilderGetQueryParameters>>? requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#nullable restore
#else
        public async Task<global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsGetResponse> GetAsResultsGetResponseAsync(Action<RequestConfiguration<global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsRequestBuilderGetQueryParameters>> requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#endif
            var requestInfo = ToGetRequestInformation(requestConfiguration);
            var errorMapping = new Dictionary<string, ParsableFactory<IParsable>>
            {
                { "424", global::Client.Generated.Models.Log_entry.CreateFromDiscriminatorValue },
                { "XXX", global::Client.Generated.Models.Error.CreateFromDiscriminatorValue },
            };
            return await RequestAdapter.SendAsync<global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsGetResponse>(requestInfo, global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsGetResponse.CreateFromDiscriminatorValue, errorMapping, cancellationToken).ConfigureAwait(false);
        }
        /// <summary>
        /// Lists signed URLs pointing to the processed files, usually after the batch jobhas finished. Back-ends may also point to intermediate results after thejob has stopped due to an error or if the `partial` parameter has been set.The response includes additional metadata. It is a valid[STAC Item](https://github.com/radiantearth/stac-spec/tree/v1.0.0/item-spec)(if it has spatial and temporal references included) or a valid[STAC Collection](https://github.com/radiantearth/stac-spec/tree/v1.0.0/collection-spec)(supported since openEO API version 1.1.0).The assets to download are in both cases available in the property `assets`and have the same structure. All additional metadata is not strictly requiredto download the files, but are helpful for users to understand the data.STAC Collections can either (1) add all assets as collection-level assets or(2) link to STAC Catalogs and STAC Items with signed URLs, which will provide a fullSTAC catalog structure a client has to go through. Option 2 is overall the better architectural choice and allows a fine-grained description of the processed data,but it is not compliant with previous versions of the openEO API.**To maintain backward compatibility, it is REQUIRED to still copyall assets in the STAC catalog structure into the collection-level assets.**This requirement is planned to be removed in openEO API version 2.0.0.A client can enforce that the server returns a GeoJSON through content negotiationwith the media type `application/geo+json`, but the results may not contain verymeaningful metadata aside from the assets.Clients are RECOMMENDED to store this response and all potential sub-catalogsand items with the assets so that the downloaded data is then a self-containedSTAC catalog user could publish easily with all the data and metadata.URL signing is a way to protect files from unauthorized access with akey in the URL instead of HTTP header based authorization. The URLsigning key is similar to a password and its inclusion in the URL allowsto download files using simple GET requests supported by a wide range ofprograms, e.g. web browsers or download managers. Back-ends areresponsible to generate the URL signing keys and to manage theirappropriate expiration. The back-end MAY indicate an expiration time bysetting the `expires` property in the reponse. Requesting this endpointSHOULD always return non-expired URLs. Signed URLs that were generatedfor a previous request and already expired SHOULD NOT be reused,but regenerated with new expiration time.Signed URLs that expired MAY return the openEO error `ResultLinkExpired`.It is **strongly recommended** to add a link with relation type `canonical`to the STAC Item or STAC Collection (see the `links` property for details).If processing has not finished yet and the `partial` parameter is not set to `true`requests to this endpoint MUST be rejected with openEO error `JobNotFinished`.
        /// </summary>
        /// <returns>A <see cref="global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsResponse"/></returns>
        /// <param name="cancellationToken">Cancellation token to use when cancelling requests</param>
        /// <param name="requestConfiguration">Configuration for the request such as headers, query parameters, and middleware options.</param>
        /// <exception cref="global::Client.Generated.Models.Log_entry">When receiving a 424 status code</exception>
        /// <exception cref="global::Client.Generated.Models.Error">When receiving a 4XX or 5XX status code</exception>
        [Obsolete("This method is obsolete. Use GetAsResultsGetResponseAsync instead.")]
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public async Task<global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsResponse?> GetAsync(Action<RequestConfiguration<global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsRequestBuilderGetQueryParameters>>? requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#nullable restore
#else
        public async Task<global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsResponse> GetAsync(Action<RequestConfiguration<global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsRequestBuilderGetQueryParameters>> requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#endif
            var requestInfo = ToGetRequestInformation(requestConfiguration);
            var errorMapping = new Dictionary<string, ParsableFactory<IParsable>>
            {
                { "424", global::Client.Generated.Models.Log_entry.CreateFromDiscriminatorValue },
                { "XXX", global::Client.Generated.Models.Error.CreateFromDiscriminatorValue },
            };
            return await RequestAdapter.SendAsync<global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsResponse>(requestInfo, global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsResponse.CreateFromDiscriminatorValue, errorMapping, cancellationToken).ConfigureAwait(false);
        }
        /// <summary>
        /// Adds a batch job to the processing queue to compute the results.The result will be stored in the format specified in the process.To specify the format use a process such as `save_result`.The job status is set to `queued`, if processing doesn&apos;t startinstantly. The same applies if the job status is `canceled`, `finished`,or `error`, which restarts the job and discards previous results if theback-end doesn&apos;t reject the request with an error.Clients SHOULD warn users and ask for confirmation if results may getdiscarded.* Once the processing starts the status is set to `running`.* Once the data is available to download the status is set to`finished`.* Whenever an error occurs during processing, the status MUST be set to`error`.This endpoint has no effect if the job status is already `queued` or`running`. In particular, it doesn&apos;t restart a running job. To restarta queued or running job, processing MUST have been canceled before.Back-ends SHOULD reject queueing jobs with openEO error `PaymentRequired`,if the back-end is able to detect that the budget is too low to fullyprocess the request. Alternatively, back-ends MAY provide partial resultsonce reaching the budget. If none of the alternatives is feasible, theresults are discarded. Thus, client SHOULD warn users that reaching thebudget may lead to partial or no results at all.
        /// </summary>
        /// <param name="cancellationToken">Cancellation token to use when cancelling requests</param>
        /// <param name="requestConfiguration">Configuration for the request such as headers, query parameters, and middleware options.</param>
        /// <exception cref="global::Client.Generated.Models.Error">When receiving a 4XX or 5XX status code</exception>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public async Task PostAsync(Action<RequestConfiguration<DefaultQueryParameters>>? requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#nullable restore
#else
        public async Task PostAsync(Action<RequestConfiguration<DefaultQueryParameters>> requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#endif
            var requestInfo = ToPostRequestInformation(requestConfiguration);
            var errorMapping = new Dictionary<string, ParsableFactory<IParsable>>
            {
                { "XXX", global::Client.Generated.Models.Error.CreateFromDiscriminatorValue },
            };
            await RequestAdapter.SendNoContentAsync(requestInfo, errorMapping, cancellationToken).ConfigureAwait(false);
        }
        /// <summary>
        /// Cancels all related computations for this job at the back-end. It willstop generating additional costs for processing.A subset of processed results may be available for downloading dependingon the state of the job at the time it was canceled.Results MUST NOT be deleted until the job processing is started again orthe job is completely deleted through a request to`DELETE /jobs/{job_id}`.This endpoint only has an effect if the job status is `queued` or`running`.The job status is set to `canceled` if the status was `running`beforehand and partial or preliminary results are available to bedownloaded. Otherwise the status is set to `created`. 
        /// </summary>
        /// <returns>A <see cref="RequestInformation"/></returns>
        /// <param name="requestConfiguration">Configuration for the request such as headers, query parameters, and middleware options.</param>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public RequestInformation ToDeleteRequestInformation(Action<RequestConfiguration<DefaultQueryParameters>>? requestConfiguration = default)
        {
#nullable restore
#else
        public RequestInformation ToDeleteRequestInformation(Action<RequestConfiguration<DefaultQueryParameters>> requestConfiguration = default)
        {
#endif
            var requestInfo = new RequestInformation(Method.DELETE, UrlTemplate, PathParameters);
            requestInfo.Configure(requestConfiguration);
            requestInfo.Headers.TryAdd("Accept", "application/json");
            return requestInfo;
        }
        /// <summary>
        /// Lists signed URLs pointing to the processed files, usually after the batch jobhas finished. Back-ends may also point to intermediate results after thejob has stopped due to an error or if the `partial` parameter has been set.The response includes additional metadata. It is a valid[STAC Item](https://github.com/radiantearth/stac-spec/tree/v1.0.0/item-spec)(if it has spatial and temporal references included) or a valid[STAC Collection](https://github.com/radiantearth/stac-spec/tree/v1.0.0/collection-spec)(supported since openEO API version 1.1.0).The assets to download are in both cases available in the property `assets`and have the same structure. All additional metadata is not strictly requiredto download the files, but are helpful for users to understand the data.STAC Collections can either (1) add all assets as collection-level assets or(2) link to STAC Catalogs and STAC Items with signed URLs, which will provide a fullSTAC catalog structure a client has to go through. Option 2 is overall the better architectural choice and allows a fine-grained description of the processed data,but it is not compliant with previous versions of the openEO API.**To maintain backward compatibility, it is REQUIRED to still copyall assets in the STAC catalog structure into the collection-level assets.**This requirement is planned to be removed in openEO API version 2.0.0.A client can enforce that the server returns a GeoJSON through content negotiationwith the media type `application/geo+json`, but the results may not contain verymeaningful metadata aside from the assets.Clients are RECOMMENDED to store this response and all potential sub-catalogsand items with the assets so that the downloaded data is then a self-containedSTAC catalog user could publish easily with all the data and metadata.URL signing is a way to protect files from unauthorized access with akey in the URL instead of HTTP header based authorization. The URLsigning key is similar to a password and its inclusion in the URL allowsto download files using simple GET requests supported by a wide range ofprograms, e.g. web browsers or download managers. Back-ends areresponsible to generate the URL signing keys and to manage theirappropriate expiration. The back-end MAY indicate an expiration time bysetting the `expires` property in the reponse. Requesting this endpointSHOULD always return non-expired URLs. Signed URLs that were generatedfor a previous request and already expired SHOULD NOT be reused,but regenerated with new expiration time.Signed URLs that expired MAY return the openEO error `ResultLinkExpired`.It is **strongly recommended** to add a link with relation type `canonical`to the STAC Item or STAC Collection (see the `links` property for details).If processing has not finished yet and the `partial` parameter is not set to `true`requests to this endpoint MUST be rejected with openEO error `JobNotFinished`.
        /// </summary>
        /// <returns>A <see cref="RequestInformation"/></returns>
        /// <param name="requestConfiguration">Configuration for the request such as headers, query parameters, and middleware options.</param>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public RequestInformation ToGetRequestInformation(Action<RequestConfiguration<global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsRequestBuilderGetQueryParameters>>? requestConfiguration = default)
        {
#nullable restore
#else
        public RequestInformation ToGetRequestInformation(Action<RequestConfiguration<global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsRequestBuilderGetQueryParameters>> requestConfiguration = default)
        {
#endif
            var requestInfo = new RequestInformation(Method.GET, UrlTemplate, PathParameters);
            requestInfo.Configure(requestConfiguration);
            requestInfo.Headers.TryAdd("Accept", "application/json");
            return requestInfo;
        }
        /// <summary>
        /// Adds a batch job to the processing queue to compute the results.The result will be stored in the format specified in the process.To specify the format use a process such as `save_result`.The job status is set to `queued`, if processing doesn&apos;t startinstantly. The same applies if the job status is `canceled`, `finished`,or `error`, which restarts the job and discards previous results if theback-end doesn&apos;t reject the request with an error.Clients SHOULD warn users and ask for confirmation if results may getdiscarded.* Once the processing starts the status is set to `running`.* Once the data is available to download the status is set to`finished`.* Whenever an error occurs during processing, the status MUST be set to`error`.This endpoint has no effect if the job status is already `queued` or`running`. In particular, it doesn&apos;t restart a running job. To restarta queued or running job, processing MUST have been canceled before.Back-ends SHOULD reject queueing jobs with openEO error `PaymentRequired`,if the back-end is able to detect that the budget is too low to fullyprocess the request. Alternatively, back-ends MAY provide partial resultsonce reaching the budget. If none of the alternatives is feasible, theresults are discarded. Thus, client SHOULD warn users that reaching thebudget may lead to partial or no results at all.
        /// </summary>
        /// <returns>A <see cref="RequestInformation"/></returns>
        /// <param name="requestConfiguration">Configuration for the request such as headers, query parameters, and middleware options.</param>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public RequestInformation ToPostRequestInformation(Action<RequestConfiguration<DefaultQueryParameters>>? requestConfiguration = default)
        {
#nullable restore
#else
        public RequestInformation ToPostRequestInformation(Action<RequestConfiguration<DefaultQueryParameters>> requestConfiguration = default)
        {
#endif
            var requestInfo = new RequestInformation(Method.POST, UrlTemplate, PathParameters);
            requestInfo.Configure(requestConfiguration);
            requestInfo.Headers.TryAdd("Accept", "application/json");
            return requestInfo;
        }
        /// <summary>
        /// Returns a request builder with the provided arbitrary URL. Using this method means any other path or query parameters are ignored.
        /// </summary>
        /// <returns>A <see cref="global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder"/></returns>
        /// <param name="rawUrl">The raw URL to use for the request builder.</param>
        public global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder WithUrl(string rawUrl)
        {
            return new global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder(rawUrl, RequestAdapter);
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Client.Generated.Jobs.Item.Results.Collection"/>, <see cref="global::Client.Generated.Models.Batch_job_result"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class ResultsGetResponse : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::Client.Generated.Models.Batch_job_result"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Client.Generated.Models.Batch_job_result? BatchJobResult { get; set; }
#nullable restore
#else
            public global::Client.Generated.Models.Batch_job_result BatchJobResult { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="global::Client.Generated.Jobs.Item.Results.Collection"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Client.Generated.Jobs.Item.Results.Collection? Collection { get; set; }
#nullable restore
#else
            public global::Client.Generated.Jobs.Item.Results.Collection Collection { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsGetResponse"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsGetResponse CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                if(ReferenceEquals(parseNode, null)) throw new ArgumentNullException(nameof(parseNode));
                var mappingValue = parseNode.GetChildNode("")?.GetStringValue();
                var result = new global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsGetResponse();
                if("batch_job_result".Equals(mappingValue, StringComparison.OrdinalIgnoreCase))
                {
                    result.BatchJobResult = new global::Client.Generated.Models.Batch_job_result();
                }
                else if("".Equals(mappingValue, StringComparison.OrdinalIgnoreCase))
                {
                    result.Collection = new global::Client.Generated.Jobs.Item.Results.Collection();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(BatchJobResult != null)
                {
                    return BatchJobResult.GetFieldDeserializers();
                }
                else if(Collection != null)
                {
                    return Collection.GetFieldDeserializers();
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                if(ReferenceEquals(writer, null)) throw new ArgumentNullException(nameof(writer));
                if(BatchJobResult != null)
                {
                    writer.WriteObjectValue<global::Client.Generated.Models.Batch_job_result>(null, BatchJobResult);
                }
                else if(Collection != null)
                {
                    writer.WriteObjectValue<global::Client.Generated.Jobs.Item.Results.Collection>(null, Collection);
                }
            }
        }
        /// <summary>
        /// Configuration for the request such as headers, query parameters, and middleware options.
        /// </summary>
        [Obsolete("This class is deprecated. Please use the generic RequestConfiguration class generated by the generator.")]
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class ResultsRequestBuilderDeleteRequestConfiguration : RequestConfiguration<DefaultQueryParameters>
        {
        }
        /// <summary>
        /// Lists signed URLs pointing to the processed files, usually after the batch jobhas finished. Back-ends may also point to intermediate results after thejob has stopped due to an error or if the `partial` parameter has been set.The response includes additional metadata. It is a valid[STAC Item](https://github.com/radiantearth/stac-spec/tree/v1.0.0/item-spec)(if it has spatial and temporal references included) or a valid[STAC Collection](https://github.com/radiantearth/stac-spec/tree/v1.0.0/collection-spec)(supported since openEO API version 1.1.0).The assets to download are in both cases available in the property `assets`and have the same structure. All additional metadata is not strictly requiredto download the files, but are helpful for users to understand the data.STAC Collections can either (1) add all assets as collection-level assets or(2) link to STAC Catalogs and STAC Items with signed URLs, which will provide a fullSTAC catalog structure a client has to go through. Option 2 is overall the better architectural choice and allows a fine-grained description of the processed data,but it is not compliant with previous versions of the openEO API.**To maintain backward compatibility, it is REQUIRED to still copyall assets in the STAC catalog structure into the collection-level assets.**This requirement is planned to be removed in openEO API version 2.0.0.A client can enforce that the server returns a GeoJSON through content negotiationwith the media type `application/geo+json`, but the results may not contain verymeaningful metadata aside from the assets.Clients are RECOMMENDED to store this response and all potential sub-catalogsand items with the assets so that the downloaded data is then a self-containedSTAC catalog user could publish easily with all the data and metadata.URL signing is a way to protect files from unauthorized access with akey in the URL instead of HTTP header based authorization. The URLsigning key is similar to a password and its inclusion in the URL allowsto download files using simple GET requests supported by a wide range ofprograms, e.g. web browsers or download managers. Back-ends areresponsible to generate the URL signing keys and to manage theirappropriate expiration. The back-end MAY indicate an expiration time bysetting the `expires` property in the reponse. Requesting this endpointSHOULD always return non-expired URLs. Signed URLs that were generatedfor a previous request and already expired SHOULD NOT be reused,but regenerated with new expiration time.Signed URLs that expired MAY return the openEO error `ResultLinkExpired`.It is **strongly recommended** to add a link with relation type `canonical`to the STAC Item or STAC Collection (see the `links` property for details).If processing has not finished yet and the `partial` parameter is not set to `true`requests to this endpoint MUST be rejected with openEO error `JobNotFinished`.
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class ResultsRequestBuilderGetQueryParameters 
        {
            /// <summary>If set to `true`, the results endpoint returns incomplete results while still running.Enabling this parameter requires to indicate the status of the batch job in the STAC metadata by setting the `openeo:status`.</summary>
            [QueryParameter("partial")]
            public bool? Partial { get; set; }
        }
        /// <summary>
        /// Configuration for the request such as headers, query parameters, and middleware options.
        /// </summary>
        [Obsolete("This class is deprecated. Please use the generic RequestConfiguration class generated by the generator.")]
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class ResultsRequestBuilderGetRequestConfiguration : RequestConfiguration<global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsRequestBuilderGetQueryParameters>
        {
        }
        /// <summary>
        /// Configuration for the request such as headers, query parameters, and middleware options.
        /// </summary>
        [Obsolete("This class is deprecated. Please use the generic RequestConfiguration class generated by the generator.")]
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class ResultsRequestBuilderPostRequestConfiguration : RequestConfiguration<DefaultQueryParameters>
        {
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Client.Generated.Jobs.Item.Results.Collection"/>, <see cref="global::Client.Generated.Models.Batch_job_result"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class ResultsResponse : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::Client.Generated.Models.Batch_job_result"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Client.Generated.Models.Batch_job_result? BatchJobResult { get; set; }
#nullable restore
#else
            public global::Client.Generated.Models.Batch_job_result BatchJobResult { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="global::Client.Generated.Jobs.Item.Results.Collection"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Client.Generated.Jobs.Item.Results.Collection? Collection { get; set; }
#nullable restore
#else
            public global::Client.Generated.Jobs.Item.Results.Collection Collection { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsResponse"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsResponse CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                if(ReferenceEquals(parseNode, null)) throw new ArgumentNullException(nameof(parseNode));
                var mappingValue = parseNode.GetChildNode("")?.GetStringValue();
                var result = new global::Client.Generated.Jobs.Item.Results.ResultsRequestBuilder.ResultsResponse();
                if("batch_job_result".Equals(mappingValue, StringComparison.OrdinalIgnoreCase))
                {
                    result.BatchJobResult = new global::Client.Generated.Models.Batch_job_result();
                }
                else if("".Equals(mappingValue, StringComparison.OrdinalIgnoreCase))
                {
                    result.Collection = new global::Client.Generated.Jobs.Item.Results.Collection();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(BatchJobResult != null)
                {
                    return BatchJobResult.GetFieldDeserializers();
                }
                else if(Collection != null)
                {
                    return Collection.GetFieldDeserializers();
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                if(ReferenceEquals(writer, null)) throw new ArgumentNullException(nameof(writer));
                if(BatchJobResult != null)
                {
                    writer.WriteObjectValue<global::Client.Generated.Models.Batch_job_result>(null, BatchJobResult);
                }
                else if(Collection != null)
                {
                    writer.WriteObjectValue<global::Client.Generated.Jobs.Item.Results.Collection>(null, Collection);
                }
            }
        }
    }
}
#pragma warning restore CS0618
